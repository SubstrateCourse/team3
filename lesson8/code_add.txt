diff --git a/lesson8/substrate-node-template/Cargo.lock b/lesson8/substrate-node-template/Cargo.lock
index 242e534..547d3e0 100644
--- a/lesson8/substrate-node-template/Cargo.lock
+++ b/lesson8/substrate-node-template/Cargo.lock
@@ -2926,9 +2926,11 @@ dependencies = [
  "frame-support",
  "frame-system",
  "parity-scale-codec",
+ "parking_lot 0.10.2",
  "sp-core",
  "sp-io",
  "sp-runtime",
+ "sp-std",
 ]
 
 [[package]]
diff --git a/lesson8/substrate-node-template/pallets/template/Cargo.toml b/lesson8/substrate-node-template/pallets/template/Cargo.toml
index 1705f3e..2fd08aa 100644
--- a/lesson8/substrate-node-template/pallets/template/Cargo.toml
+++ b/lesson8/substrate-node-template/pallets/template/Cargo.toml
@@ -8,6 +8,11 @@ name = 'pallet-template'
 repository = 'https://github.com/substrate-developer-hub/substrate-node-template/'
 version = '2.0.0-rc2'
 
+
+[dependencies]
+sp-std = { git = 'https://github.com/paritytech/substrate', tag = 'v2.0.0-rc2', version = '2.0.0-rc2', default-features = false }
+parking_lot = "0.10.0"
+
 [dependencies.codec]
 default-features = false
 features = ['derive']
@@ -26,24 +31,25 @@ git = 'https://github.com/paritytech/substrate.git'
 tag = 'v2.0.0-rc2'
 version = '2.0.0-rc2'
 
-[dev-dependencies.sp-core]
+[dependencies.sp-core]
 default-features = false
 git = 'https://github.com/paritytech/substrate.git'
 tag = 'v2.0.0-rc2'
 version = '2.0.0-rc2'
 
-[dev-dependencies.sp-io]
+[dependencies.sp-io]
 default-features = false
 git = 'https://github.com/paritytech/substrate.git'
 tag = 'v2.0.0-rc2'
 version = '2.0.0-rc2'
 
-[dev-dependencies.sp-runtime]
+[dependencies.sp-runtime]
 default-features = false
 git = 'https://github.com/paritytech/substrate.git'
 tag = 'v2.0.0-rc2'
 version = '2.0.0-rc2'
 
+
 [features]
 default = ['std']
 std = [
diff --git a/lesson8/substrate-node-template/pallets/template/src/lib.rs b/lesson8/substrate-node-template/pallets/template/src/lib.rs
index 74380bc..0275ebc 100644
--- a/lesson8/substrate-node-template/pallets/template/src/lib.rs
+++ b/lesson8/substrate-node-template/pallets/template/src/lib.rs
@@ -8,24 +8,68 @@
 
 /// For more guidance on Substrate FRAME, see the example pallet
 /// https://github.com/paritytech/substrate/blob/master/frame/example/src/lib.rs
+use core::{convert::TryInto};
+use frame_support::{debug, decl_module, decl_storage, decl_event, dispatch};
+use frame_system::{self as system, ensure_signed,
+	offchain::{
+		AppCrypto, CreateSignedTransaction, SendSignedTransaction, Signer
+	},
+};
 
-use frame_support::{debug, decl_module, decl_storage, decl_event, decl_error, dispatch};
-use frame_system::{self as system, ensure_signed};
+
+use sp_core::crypto::KeyTypeId;
+use sp_std::prelude::*;
 
 #[cfg(test)]
 mod mock;
 
 #[cfg(test)]
 mod tests;
+pub const KEY_TYPE: KeyTypeId = KeyTypeId(*b"ocw8");
 
 /// The pallet's configuration trait.
-pub trait Trait: system::Trait {
+pub trait Trait: system::Trait  + CreateSignedTransaction<Call<Self>> {
 	// Add other types and constants required to configure this pallet.
 
+	/// The overarching event type.
+	type AuthorityId: AppCrypto<Self::Public, Self::Signature>;
+	/// The overarching dispatch call type.
+	type Call: From<Call<Self>>;
 	/// The overarching event type.
 	type Event: From<Event<Self>> + Into<<Self as system::Trait>::Event>;
 }
 
+
+pub mod crypto {
+	use crate::KEY_TYPE;
+	use sp_core::sr25519::Signature as Sr25519Signature;
+	use sp_runtime::{
+		app_crypto::{app_crypto, sr25519},
+		traits::Verify,
+		MultiSignature, MultiSigner,
+	};
+
+	app_crypto!(sr25519, KEY_TYPE);
+
+	pub struct AuthId;
+	// implemented for ocw-runtime
+	impl frame_system::offchain::AppCrypto<MultiSigner, MultiSignature> for AuthId {
+		type RuntimeAppPublic = Public;
+		type GenericSignature = sp_core::sr25519::Signature;
+		type GenericPublic = sp_core::sr25519::Public;
+	}
+
+	// implemented for mock runtime in test
+	impl frame_system::offchain::AppCrypto<<Sr25519Signature as Verify>::Signer, Sr25519Signature>
+		for AuthId
+	{
+		type RuntimeAppPublic = Public;
+		type GenericSignature = sp_core::sr25519::Signature;
+		type GenericPublic = sp_core::sr25519::Public;
+	}
+}
+
+
 // This pallet's storage items.
 decl_storage! {
 	// It is important to update your storage name so that your pallet's
@@ -35,7 +79,9 @@ decl_storage! {
 		// Just a dummy storage item.
 		// Here we are declaring a StorageValue, `Something` as a Option<u32>
 		// `get(fn something)` is the default getter which returns either the stored `u32` or `None` if nothing stored
-		Something get(fn something): Option<u32>;
+		// Something get(fn something): Option<u32>;
+
+		Numbers get(fn numbers): map hasher(blake2_128_concat) u64 => u64;
 	}
 }
 
@@ -45,19 +91,20 @@ decl_event!(
 		/// Just a dummy event.
 		/// Event `Something` is declared with a parameter of the type `u32` and `AccountId`
 		/// To emit this event, we call the deposit function, from our runtime functions
-		SomethingStored(u32, AccountId),
+		// SomethingStored(u32, AccountId),
+		NumberAppended(AccountId, u64, u64),
 	}
 );
 
 // The pallet's errors
-decl_error! {
-	pub enum Error for Module<T: Trait> {
-		/// Value was None
-		NoneValue,
-		/// Value reached maximum and cannot be incremented further
-		StorageOverflow,
-	}
-}
+// decl_error! {
+// 	pub enum Error for Module<T: Trait> {
+// 		/// Value was None
+// 		NoneValue,
+// 		/// Value reached maximum and cannot be incremented further
+// 		StorageOverflow,
+// 	}
+// }
 
 // The pallet's dispatchable functions.
 decl_module! {
@@ -66,31 +113,64 @@ decl_module! {
 		// Initializing errors
 		// this includes information about your errors in the node's metadata.
 		// it is needed only if you are using errors in your pallet
-		type Error = Error<T>;
+		// type Error = Error<T>;
 
 		// Initializing events
 		// this is needed only if you are using events in your pallet
 		fn deposit_event() = default;
 
 		#[weight = 10_000]
-		pub fn save_number(origin, number: u32) -> dispatch::DispatchResult {
+		pub fn save_number(origin, index: u64, number: u64) -> dispatch::DispatchResult {
 			// Check it was signed and get the signer. See also: ensure_root and ensure_none
 			let who = ensure_signed(origin)?;
 
 			/*******
 			 * 学员们在这里追加逻辑
 			 *******/
-
+			Numbers::insert(index, number);
+			Self::deposit_event(RawEvent::NumberAppended(who, index, number));
 			Ok(())
 		}
 
 		fn offchain_worker(block_number: T::BlockNumber) {
-			debug::info!("Entering off-chain workers");
+			debug::info!("Entering off-chain workers: {:?}", block_number);
 
 			/*******
 			 * 学员们在这里追加逻辑
 			 *******/
+			 Self::submit_number(block_number);
 		}
 
 	}
 }
+
+impl<T: Trait> Module<T> {
+	fn submit_number(block_number: T::BlockNumber) {
+		let index: u64 = block_number.try_into().ok().unwrap() as u64;
+		let latest = if index > 0 {
+			Self::numbers((index - 1) as u64)
+		} else {
+			0
+		};
+
+		let new: u64 = latest.saturating_add((index + 1).saturating_pow(2));
+
+		let signer = Signer::<T, T::AuthorityId>::all_accounts();
+		if !signer.can_sign() {
+			debug::error!("No local account available");
+			return;
+		}
+
+		let results = signer.send_signed_transaction(|_acct| {
+			// We are just submitting the current block number back on-chain
+			Call::save_number(index, new)
+		});
+
+		for (_acc, res) in &results {
+			match res {
+				Ok(()) => { debug::native::info!("off-chain tx succeeded: number: {}", new); }
+				Err(_e) => { debug::error!("off-chain tx failed: number: {}", new); }
+			};
+		}
+	}
+}
\ No newline at end of file
diff --git a/lesson8/substrate-node-template/pallets/template/src/mock.rs b/lesson8/substrate-node-template/pallets/template/src/mock.rs
index 4eed0e1..d2af988 100644
--- a/lesson8/substrate-node-template/pallets/template/src/mock.rs
+++ b/lesson8/substrate-node-template/pallets/template/src/mock.rs
@@ -1,22 +1,47 @@
 // Creating mock runtime here
 
-use crate::{Module, Trait};
-use sp_core::H256;
-use frame_support::{impl_outer_origin, parameter_types, weights::Weight};
+use crate::{Module, Trait, Call, crypto, KEY_TYPE};
+use sp_core::{
+	H256,
+	offchain::{
+		testing::{self, OffchainState, PoolState},
+		OffchainExt, TransactionPoolExt,
+	},
+	sr25519::{self, Signature},
+	testing::KeyStore,
+	traits::KeystoreExt,
+};
+
+use codec::{alloc::sync::Arc};
+use parking_lot::RwLock;
+
+use frame_support::{impl_outer_origin, impl_outer_event, parameter_types, weights::Weight};
+use sp_io::TestExternalities;
 use sp_runtime::{
-	traits::{BlakeTwo256, IdentityLookup}, testing::Header, Perbill,
+	testing::{Header, TestXt},
+	traits::{BlakeTwo256, IdentityLookup, Verify},
+	Perbill,
 };
 use frame_system as system;
+use crate as template;
 
 impl_outer_origin! {
 	pub enum Origin for Test {}
 }
 
+impl_outer_event! {
+	pub enum TestEvent for Test {
+		system<T>,
+		template<T>,
+	}
+}
+
 // For testing the pallet, we construct most of a mock runtime. This means
 // first constructing a configuration type (`Test`) which `impl`s each of the
 // configuration traits of pallets we want to use.
 #[derive(Clone, Eq, PartialEq)]
 pub struct Test;
+
 parameter_types! {
 	pub const BlockHashCount: u64 = 250;
 	pub const MaximumBlockWeight: Weight = 1024;
@@ -30,10 +55,10 @@ impl system::Trait for Test {
 	type BlockNumber = u64;
 	type Hash = H256;
 	type Hashing = BlakeTwo256;
-	type AccountId = u64;
+	type AccountId = sr25519::Public;
 	type Lookup = IdentityLookup<Self::AccountId>;
 	type Header = Header;
-	type Event = ();
+	type Event = TestEvent;
 	type BlockHashCount = BlockHashCount;
 	type MaximumBlockWeight = MaximumBlockWeight;
 	type DbWeight = ();
@@ -48,13 +73,77 @@ impl system::Trait for Test {
 	type OnNewAccount = ();
 	type OnKilledAccount = ();
 }
+
+// --- mocking template trait
+pub type TestExtrinsic = TestXt<Call<Test>, ()>;
+
 impl Trait for Test {
-	type Event = ();
+	type AuthorityId = crypto::AuthId;
+	type Call = Call<Test>;
+	type Event = TestEvent;
+}
+
+impl<LocalCall> system::offchain::CreateSignedTransaction<LocalCall> for Test
+where
+	Call<Test>: From<LocalCall>,
+{
+	fn create_transaction<C: frame_system::offchain::AppCrypto<Self::Public, Self::Signature>>(
+		call: Call<Test>,
+		_public: <Signature as Verify>::Signer,
+		_account: <Test as system::Trait>::AccountId,
+		index: <Test as system::Trait>::Index,
+	) -> Option<(
+		Call<Test>,
+		<TestExtrinsic as sp_runtime::traits::Extrinsic>::SignaturePayload,
+	)> {
+		Some((call, (index, ())))
+	}
+}
+
+impl system::offchain::SigningTypes for Test {
+	type Public = <Signature as Verify>::Signer;
+	type Signature = Signature;
 }
-pub type TemplateModule = Module<Test>;
 
-// This function basically just builds a genesis storage key/value store according to
-// our desired mockup.
-pub fn new_test_ext() -> sp_io::TestExternalities {
-	system::GenesisConfig::default().build_storage::<Test>().unwrap().into()
+impl<C> system::offchain::SendTransactionTypes<C> for Test
+where
+	Call<Test>: From<C>,
+{
+	type OverarchingCall = Call<Test>;
+	type Extrinsic = TestExtrinsic;
 }
+
+pub type System = system::Module<Test>;
+pub type TemplateModule = Module<Test>;
+
+pub struct ExtBuilder;
+
+impl ExtBuilder {
+	pub fn build() -> (
+		TestExternalities,
+		Arc<RwLock<PoolState>>,
+		Arc<RwLock<OffchainState>>,
+	) {
+		const PHRASE: &str =
+			"expire stage crawl shell boss any story swamp skull yellow bamboo copy";
+
+		let (offchain, offchain_state) = testing::TestOffchainExt::new();
+		let (pool, pool_state) = testing::TestTransactionPoolExt::new();
+		let keystore = KeyStore::new();
+		keystore
+			.write()
+			.sr25519_generate_new(KEY_TYPE, Some(&format!("{}/hunter1", PHRASE)))
+			.unwrap();
+
+		let storage = system::GenesisConfig::default()
+			.build_storage::<Test>()
+			.unwrap();
+
+		let mut t = TestExternalities::from(storage);
+		t.register_extension(OffchainExt::new(offchain));
+		t.register_extension(TransactionPoolExt::new(pool));
+		t.register_extension(KeystoreExt(keystore));
+		t.execute_with(|| System::set_block_number(1));
+		(t, pool_state, offchain_state)
+	}
+}
\ No newline at end of file
diff --git a/lesson8/substrate-node-template/pallets/template/src/tests.rs b/lesson8/substrate-node-template/pallets/template/src/tests.rs
index 609ca4b..1387859 100644
--- a/lesson8/substrate-node-template/pallets/template/src/tests.rs
+++ b/lesson8/substrate-node-template/pallets/template/src/tests.rs
@@ -1,18 +1,66 @@
 // Tests to be written here
 
-use crate::{Error, mock::*};
-use frame_support::{assert_ok, assert_noop};
+use crate::{*, mock::*};
+use frame_support::{assert_ok};
+use codec::{Decode};
 
 #[test]
 fn test_onchain() {
-	new_test_ext().execute_with(|| {
-		// Test onchain logic here
+	let (mut t, _pool_state, _offchain_state) = ExtBuilder::build();
+	t.execute_with(|| {
+		let index = 1;
+		let value = 2;
+		let acct: <Test as system::Trait>::AccountId = Default::default();
+
+		// when `save_number` is being called
+		assert_ok!(TemplateModule::save_number(Origin::signed(acct), index , value));
+
+		// added to storage
+		assert_eq!(<Numbers>::get(index), value);
+
+		// an event is emitted
+		let expected_event = TestEvent::template(RawEvent::NumberAppended(acct, index, value));
+		assert!( System::events().iter().any(|er| er.event == expected_event) );
+
 	});
 }
 
 #[test]
 fn test_offchain() {
-	new_test_ext().execute_with(|| {
-		// Test offchain worker here
+	let (mut t, pool_state, _offchain_state) = ExtBuilder::build();
+
+	let acct: <Test as system::Trait>::AccountId = Default::default();
+
+	t.execute_with(|| {
+		// 4 submit_number being called
+		TemplateModule::submit_number(0);
+		assert_ok!(TemplateModule::save_number(Origin::signed(acct), 0, 1));
+
+		TemplateModule::submit_number(1);
+		assert_ok!(TemplateModule::save_number(Origin::signed(acct), 1, 5));
+
+		TemplateModule::submit_number(2);
+		assert_ok!(TemplateModule::save_number(Origin::signed(acct), 2, 14));
+
+		TemplateModule::submit_number(3);
+
+		// check proper calls are being added to the transaction pools
+		let tx4 = pool_state.write().transactions.pop().unwrap();
+		let tx3 = pool_state.write().transactions.pop().unwrap();
+		let tx2 = pool_state.write().transactions.pop().unwrap();
+		let tx1 = pool_state.write().transactions.pop().unwrap();
+		assert!(pool_state.read().transactions.is_empty());
+
+		let tx1decoded = TestExtrinsic::decode(&mut &*tx1).unwrap();
+		assert_eq!(tx1decoded.call, Call::save_number(0, 1));
+
+		let tx2decoded = TestExtrinsic::decode(&mut &*tx2).unwrap();
+		assert_eq!(tx2decoded.call, Call::save_number(1, 5));
+
+		let tx3decoded = TestExtrinsic::decode(&mut &*tx3).unwrap();
+		assert_eq!(tx3decoded.call, Call::save_number(2, 14));
+
+		let tx4decoded = TestExtrinsic::decode(&mut &*tx4).unwrap();
+		assert_eq!(tx4decoded.call, Call::save_number(3, 30));
 	});
 }
diff --git a/lesson8/substrate-node-template/runtime/src/lib.rs b/lesson8/substrate-node-template/runtime/src/lib.rs
index 55fa4cd..5236f48 100644
--- a/lesson8/substrate-node-template/runtime/src/lib.rs
+++ b/lesson8/substrate-node-template/runtime/src/lib.rs
@@ -9,10 +9,13 @@
 include!(concat!(env!("OUT_DIR"), "/wasm_binary.rs"));
 
 use sp_std::prelude::*;
-use sp_core::{crypto::KeyTypeId, OpaqueMetadata};
+use sp_core::{crypto::KeyTypeId, OpaqueMetadata, Encode};
 use sp_runtime::{
 	ApplyExtrinsicResult, generic, create_runtime_str, impl_opaque_keys, MultiSignature,
 	transaction_validity::{TransactionValidity, TransactionSource},
+	traits::{
+		SaturatedConversion
+	}
 };
 use sp_runtime::traits::{
 	BlakeTwo256, Block as BlockT, IdentityLookup, Verify, IdentifyAccount, NumberFor, Saturating,
@@ -32,6 +35,7 @@ pub use timestamp::Call as TimestampCall;
 pub use balances::Call as BalancesCall;
 pub use sp_runtime::{Permill, Perbill};
 pub use frame_support::{
+	debug,
 	construct_runtime, parameter_types, StorageValue,
 	traits::{KeyOwnerProofSystem, Randomness},
 	weights::{
@@ -239,6 +243,8 @@ parameter_types! {
 	pub const TransactionByteFee: Balance = 1;
 }
 
+pub type SignedPayload = generic::SignedPayload<Call, SignedExtra>;
+
 impl transaction_payment::Trait for Runtime {
 	type Currency = balances::Module<Runtime>;
 	type OnTransactionPayment = ();
@@ -254,7 +260,65 @@ impl sudo::Trait for Runtime {
 
 /// Used for the module template in `./template.rs`
 impl template::Trait for Runtime {
+	type AuthorityId = template::crypto::AuthId;
 	type Event = Event;
+	type Call = Call;
+}
+
+impl<LocalCall> system::offchain::CreateSignedTransaction<LocalCall> for Runtime
+where
+	Call: From<LocalCall>,
+{
+	fn create_transaction<C: system::offchain::AppCrypto<Self::Public, Self::Signature>>(
+		call: Call,
+		public: <Signature as sp_runtime::traits::Verify>::Signer,
+		account: AccountId,
+		index: Index,
+	) -> Option<(
+		Call,
+		<UncheckedExtrinsic as sp_runtime::traits::Extrinsic>::SignaturePayload,
+	)> {
+		let period = BlockHashCount::get() as u64;
+		let current_block = System::block_number()
+			.saturated_into::<u64>()
+			.saturating_sub(1);
+		let tip = 0;
+
+		let extra: SignedExtra = (
+			system::CheckTxVersion::<Runtime>::new(),
+			system::CheckGenesis::<Runtime>::new(),
+			system::CheckEra::<Runtime>::from(generic::Era::mortal(period, current_block)),
+			system::CheckNonce::<Runtime>::from(index),
+			system::CheckWeight::<Runtime>::new(),
+			transaction_payment::ChargeTransactionPayment::<Runtime>::from(tip),
+		);
+
+		#[cfg_attr(not(feature = "std"), allow(unused_variables))]
+		let raw_payload = SignedPayload::new(call, extra)
+			.map_err(|e| {
+				debug::native::warn!("SignedPayload error: {:?}", e);
+			})
+			.ok()?;
+
+		let signature = raw_payload.using_encoded(|payload| C::sign(payload, public))?;
+
+		let address = account;
+		let (call, extra, _) = raw_payload.deconstruct();
+		Some((call, (address, signature, extra)))
+	}
+}
+
+impl system::offchain::SigningTypes for Runtime {
+	type Public = <Signature as sp_runtime::traits::Verify>::Signer;
+	type Signature = Signature;
+}
+
+impl<C> system::offchain::SendTransactionTypes<C> for Runtime
+where
+	Call: From<C>,
+{
+	type OverarchingCall = Call;
+	type Extrinsic = UncheckedExtrinsic;
 }
 
 construct_runtime!(
@@ -288,7 +352,6 @@ pub type SignedBlock = generic::SignedBlock<Block>;
 pub type BlockId = generic::BlockId<Block>;
 /// The SignedExtension to the basic transaction logic.
 pub type SignedExtra = (
-	system::CheckSpecVersion<Runtime>,
 	system::CheckTxVersion<Runtime>,
 	system::CheckGenesis<Runtime>,
 	system::CheckEra<Runtime>,
